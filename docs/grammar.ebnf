program             ::= { statement } EOF ;

statement           ::= scope
                      | if_statement
                      | while_statement
                      | until_statement
                      | symbol_declaration
                      | assignment
                      | expr_statement
                      ;

scope               ::= "{" { statement } "}" ;

expr_statement      ::= expr ";" ;

symbol_declaration  ::= decl_scope [ decl_modifier ] IDENT "=" expr ";" ;
decl_modifier       ::= "const"
decl_scope          ::= "local" | "global" | "export" ;

assignment          ::= lvalue "=" expr ";" ;

lvalue              ::= lvalue_start { lvalue_step } ;
lvalue_start        ::= IDENT | "(" expr ")" ;

lvalue_step         ::= member_access
                      | call_then_member
                      ;

call_then_member    ::= call member_access { member_access } ;

if_statement        ::= "if" expr statement [ "else" statement ] ;

while_statement     ::= "while" expr statement;

until_statement     ::= "until" expr statement;

(* Expressions: precedence (lowest -> highest)
   1) ||, &&
   2) ==, !=, <, <=, >=, >
   3) +, -
   4) *, /
   5) postfix
   6) atom / unary
*)
expr                ::= comp_expr { ( "||" | "&&" ) comp_expr } ;
comp_expr           ::= arith_expr { ( "==" | "!=" | "<" | "<=" | ">=" | ">" ) arith_expr } ;
arith_expr          ::= term { ( "+" | "-" ) term } ;
term                ::= postfix { ( "*" | "/" ) postfix } ;

postfix             ::= atom { postfix_op } ;
postfix_op          ::= member_access | call ;

member_access       ::= "." IDENT ;

call                ::= "(" [ arg_list ] ")" ;
arg_list            ::= expr { "," expr } ;

atom                ::= "(" expr ")"
                      | unary
                      | INT
                      | FLOAT
                      | STRING
                      | IDENT
                      ;

unary               ::= ( "+" | "-" ) atom ;
